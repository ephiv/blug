[
  {
    "id": "1",
    "title": "first post",
    "date": "2025-08-23",
    "excerpt": "markdown testing",
    "content": "# hello\n\nwe be testing **markdown**:\n\n## basics\n\n- **big black bold wide fat**\n- *slim jim micheal jackson*\n- `inline code`\n- [linky link link](https://example.com)\n\n```c\nint main() {\n    std::cout << \"Hello World\" << std::endl;\n}\n```\n\n> blockquote go brr\n\nok i hope it looks good and not stupid ok bye!!"
  },
  {
    "id": "2",
    "title": "weekdays",
    "date": "2025-08-24",
    "excerpt": "how yall getting days of the week using the date",
    "content": "```py\ndef dayOfWeek(year, month, day):\n    t = [0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4]\n\n    if month < 3:\n        year -= 1\n\n    return (year + year // 4 - year // 100 + year // 400 + t[month - 1] + day) % 7\n\nmapping = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\nprint(mapping[dayOfWeek(2025, 8, 24)])\n```\n\nthis is called uhh the tomohiko sakamoto's algorithm.\nim too lazy to express your concepts in text so here's this.\n```py\nimport math\n\nC = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334] # days before month\n\ndef totaldays(y, m, d):\n    return 365*y + math.floor(y/4) - math.floor(y/100) + math.floor(y/400) + C[m] + (d - 1)\n\nprint(f\"Total days since 2025-08-24 if all years are non-leap years are: {totaldays(2025, 8, 24)}\")\n```\n```\n[fivy@archlinux playground]$ venv/bin/python main.py\nTotal days since 0000-01-01 if all years are non-leap years are: 739882\n```\nthis is correct, it has been 739882 days since 0000-01-01 if all years were common.\n```py\nimport math\n\nC = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334] # days before month\nt0 = []\n\nfor i in range(len(C)):\n    t0.append((C[i]-1) % 7)\n\nprint(t0)\n\ndef day(y, m, d):\n    return (y + math.floor(y/4) - math.floor(y/100) + math.floor(y/400) + t0[m] + d) % 7\n\nprint(f\"Weekday of date if all years are non-leap years are: {day(2025, 8, 24)}\")\n```\n[fivy@archlinux playground]$ venv/bin/python main.py\n[6, 2, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4]\nWeekday of date if all years are non-leap years are: 3\n```\nto convert the days since the first gregorian day, mod 7 the result, 365 = 1 mod 7 so 365*y = y mod 7 and C[m]-1 mod 7 is t0\n*we transpose the -1 to C[m] for the t0 because we count from day 1 to 31 (max)*\nnow we're gonna go back to the original code\nwhy `y -= m < 3`? cuz leap-year stupi-\nby using january as *undecember* and febuary as *duodecember* of the last year,\n```py\nconsec = [\n    mapping[dayOfWeek(2024, 2, 28)],\n    mapping[dayOfWeek(2024, 2, 29)],\n    mapping[dayOfWeek(2024, 3, 1)],\n    mapping[dayOfWeek(2024, 3, 2)]\n]\n\nprint(str(consec))\n```\n```\n[fivy@archlinux playground]$ venv/bin/python main.py\n['Wednesday', 'Thursday', 'Friday', 'Saturday']\n```\nit treats leap days correctly.\n\nbut one more thing, our list was `[6, 2, 2,...`, what is `[0, 3, 2,...`?\nit's compensation for the trick\n`6 + 1 = 0 mod 7`\n`2 + 1 = 3 mod 7`\n\nok bye bye"
  }
]
